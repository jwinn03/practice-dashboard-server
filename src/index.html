<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Practice Server</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f4f7f9; padding: 1em; color: #333; line-height: 1.6; }
        .container { max-width: 600px; margin: 0 auto; background: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1, h2 { color: #1a202c; border-bottom: 1px solid #e2e8f0; padding-bottom: 0.5rem; margin-bottom: 1rem;}
        #status { font-weight: bold; }
        button { background-color: #4299e1; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px; transition: background-color 0.2s; }
        button:hover { background-color: #2b6cb0; }
        button:disabled { background-color: #a0aec0; cursor: not-allowed; }
        audio { margin-top: 20px; width: 100%; }
        .tuner { margin-top: 2rem; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; }
        .tuner-display { display: flex; justify-content: space-around; text-align: center; font-size: 1.2em; }
        .tuner-display div { flex: 1; }
        .tuner-display span { display: block; font-size: 1.8em; font-weight: bold; }
        #historyLog { margin-top: 1rem; max-height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; padding: 1rem; border-radius: 8px; font-family: monospace; font-size: 0.9em; }
        input[type="file"] { margin-top: 10px; }
        
        /* Custom Audio Player Styles */
        .audio-player-container { margin-top: 1rem; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc; }
        .audio-player-controls { display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; }
        .audio-player-controls button { margin-right: 0; padding: 8px 16px; font-size: 14px; }
        .audio-progress-container { position: relative; width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; cursor: pointer; margin: 0.5rem 0; }
        .audio-progress-bar { height: 100%; background: #4299e1; border-radius: 4px; width: 0%; transition: width 0.1s ease; }
        .audio-time-display { display: flex; justify-content: space-between; font-size: 0.9em; color: #666; margin-top: 0.25rem; }
        .audio-volume-container { display: flex; align-items: center; gap: 0.5rem; }
        .audio-volume-container input[type="range"] { width: 80px; }
        
        .chart-container { margin-top: 1rem; position: relative; height: 300px; width: 100%; }
        .chart-container canvas { max-height: 300px; cursor: crosshair; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Music Practice Server</h1>
        <p>Status: <span id="status">Connecting...</span></p>
        
        <h2>Live Recording</h2>
        <div>
            <button id="recordBtn">Record 5s</button>
            <button id="playBtn" disabled>Play</button>
        </div>
        
        <hr style="margin: 2rem 0;">

        <h2>Analyze WAV File</h2>
        <input type="file" id="fileInput" accept=".wav">
        <audio id="audioPlayer" controls style="display: none;"></audio>
        
        <!-- Custom Audio Player Interface -->
        <div class="audio-player-container" id="audioPlayerContainer" style="display: none;">
            <h3 style="margin-top: 0; margin-bottom: 1rem;">Audio Player</h3>
            <div class="audio-player-controls">
                <button id="playPauseBtn">Play</button>
                <button id="stopBtn">Stop</button>
                <div class="audio-volume-container">
                    <span>ðŸ”Š</span>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1">
                </div>
            </div>
            <div class="audio-progress-container" id="progressContainer">
                <div class="audio-progress-bar" id="progressBar"></div>
            </div>
            <div class="audio-time-display">
                <span id="currentTime">0:00</span>
                <span id="totalTime">0:00</span>
            </div>
        </div>
        
        <div id="historyLog">Analysis history will appear here...</div>
        <div class="chart-container">
            <canvas id="accuracyChart"></canvas>
        </div>

        <div class="tuner">
            <h2>Real-Time Tuner</h2>
            <div class="tuner-display">
                <div>Note<span id="note">--</span></div>
                <div>Freq (Hz)<span id="frequency">--</span></div>
                <div>Cents<span id="cents">--</span></div>
                <div>Accuracy<span id="accuracy">--</span></div>
            </div>
        </div>
    </div>

    <!-- SCRIPT IS NOW A MODULE TO SUPPORT ESM IMPORT -->
    <script type="module">
        // Import the PitchDetector class from the pitchy ES Module
        import { PitchDetector } from 'https://esm.sh/pitchy@4.1.0';

        // DOM Elements
        const statusElement = document.getElementById('status');
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const audioPlayer = document.getElementById('audioPlayer');
        const noteEl = document.getElementById('note');
        const frequencyEl = document.getElementById('frequency');
        const centsEl = document.getElementById('cents');
        const accuracyEl = document.getElementById('accuracy');
        const historyLog = document.getElementById('historyLog');
        const fileInput = document.getElementById('fileInput');
        const accuracyChartCanvas = document.getElementById('accuracyChart');
        
        // Custom Audio Player Elements
        const audioPlayerContainer = document.getElementById('audioPlayerContainer');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const volumeSlider = document.getElementById('volumeSlider');

        // Audio & Recording Constants
        const LIVE_SAMPLE_RATE = 16000;
        const RECORD_DURATION_MS = 5000;
        const ANALYSIS_BUFFER_SIZE = 2048;

        // State Variables
        let isRecording = false;
        let audioChunks = [];
        let accuracyHistory = [];
        let pitchyDetector;
        let audioContext;
        let accuracyChart;
        let currentAudioHistory = []; // Store current audio analysis history
        
        // --- NOTE & FREQUENCY DATA ---
        const A4 = 440;
        const noteNames = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
        const standardFrequencies = {};
        for (let i = 0; i < 88; i++) {
            const freq = A4 * Math.pow(2, (i - 48) / 12);
            const octave = Math.floor((i + 9) / 12); //change - remove -1
            const noteName = noteNames[i % 12];
            standardFrequencies[freq] = `${noteName}${octave}`;
        }
        const sortedFreqs = Object.keys(standardFrequencies).map(Number).sort((a, b) => a - b);


        // --- WEBSOCKET SETUP ---
        const ws = new WebSocket(`ws://${window.location.host}`);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            console.log('WebSocket connection opened');
            statusElement.textContent = 'Connected';
            statusElement.style.color = 'green';
        };

        ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
                const pcmData = new Int16Array(event.data);
                if (isRecording) {
                    audioChunks.push(pcmData);
                }
                const analysisResult = analyzePitch(pcmData, LIVE_SAMPLE_RATE);
                if (isRecording && analysisResult) {
                     const time = (audioChunks.length * pcmData.length / LIVE_SAMPLE_RATE).toFixed(2);
                     accuracyHistory.push({ time, ...analysisResult });
                }
            }
        };

        ws.onclose = () => {
            console.log('WebSocket connection closed');
            statusElement.textContent = 'Disconnected';
            statusElement.style.color = 'red';
        };

        // --- PITCH DETECTION & ANALYSIS ---
        window.addEventListener('load', () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            // Use the imported PitchDetector directly
            pitchyDetector = PitchDetector.forFloat32Array(ANALYSIS_BUFFER_SIZE);
        });

        function analyzePitch(pcmData, sampleRate) {
            if (!pitchyDetector) return null;

            let pcmFloat32Data;
            if (pcmData instanceof Int16Array) {
                pcmFloat32Data = new Float32Array(pcmData.length);
                for (let i = 0; i < pcmData.length; i++) {
                    pcmFloat32Data[i] = pcmData[i] / 32768.0;
                }
            } else {
                pcmFloat32Data = pcmData;
            }

            const [pitch, clarity] = pitchyDetector.findPitch(pcmFloat32Data, sampleRate);

            // Lowered clarity threshold for better detection of pure tones
            if (clarity > 0.9) {
                const { targetFreq, noteName } = findClosestNote(pitch);
                const cents = 1200 * Math.log2(pitch / targetFreq);
                const accuracy = Math.max(0, 100 - (Math.abs(cents) * 2));

                noteEl.textContent = noteName;
                frequencyEl.textContent = pitch.toFixed(1);
                centsEl.textContent = cents.toFixed(1);
                accuracyEl.textContent = `${accuracy.toFixed(0)}%`;

                return { pitch: pitch.toFixed(1), noteName, cents: cents.toFixed(1), accuracy: accuracy.toFixed(0) };
            }
            return null;
        }

        function findClosestNote(frequency) {
            let closestFreq = sortedFreqs[0];
            for (let i = 1; i < sortedFreqs.length; i++) {
                if (Math.abs(sortedFreqs[i] - frequency) < Math.abs(closestFreq - frequency)) {
                    closestFreq = sortedFreqs[i];
                }
            }
            return { targetFreq: closestFreq, noteName: standardFrequencies[closestFreq] };
        }


        // --- LIVE RECORDING & PLAYBACK ---
        recordBtn.onclick = () => {
            isRecording = true;
            recordBtn.disabled = true;
            playBtn.disabled = true;
            audioChunks = [];
            accuracyHistory = [];
            historyLog.innerHTML = 'Recording live audio...';
            statusElement.textContent = 'Recording...';

            setTimeout(() => {
                isRecording = false;
                recordBtn.disabled = false;
                statusElement.textContent = 'Recording finished.';
                
                displayHistory(accuracyHistory, 'live');

                if (audioChunks.length > 0) {
                    const audioBlob = createWavBlob(audioChunks);
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayer.src = audioUrl;
                    playBtn.disabled = false;
                    
                    // Show custom audio player
                    audioPlayerContainer.style.display = 'block';
                } else {
                    historyLog.innerHTML = 'No audio data received during recording.';
                }
            }, RECORD_DURATION_MS);
        };
        
        playBtn.onclick = () => {
            audioPlayer.play();
        };

        // --- FILE UPLOAD & ANALYSIS ---
        fileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                //historyLog.innerHTML = 'Analyzing file...';
                //historyLog.innerHTML = JSON.stringify(standardFrequencies, null, 2);

                
                audioContext.decodeAudioData(e.target.result, (audioBuffer) => {
                    const pcmData = audioBuffer.getChannelData(0);
                    const sampleRate = audioBuffer.sampleRate;
                    const fileAccuracyHistory = [];

                    for (let i = 0; i < pcmData.length - ANALYSIS_BUFFER_SIZE; i += ANALYSIS_BUFFER_SIZE) {
                        const chunk = pcmData.slice(i, i + ANALYSIS_BUFFER_SIZE);
                        const result = analyzePitch(chunk, sampleRate);
                        if(result) {
                            const time = (i / sampleRate).toFixed(2);
                            fileAccuracyHistory.push({ time, ...result });
                        }
                        console.log(i);
                        
                    }
                    console.log("pcmdata length: " + pcmData.length);
                    displayHistory(fileAccuracyHistory, 'file');
                    
                    const fileUrl = URL.createObjectURL(file);
                    audioPlayer.src = fileUrl;
                    playBtn.disabled = false;
                    
                    // Show custom audio player
                    audioPlayerContainer.style.display = 'block';
                });
            };
            reader.readAsArrayBuffer(file);

            
        };

        // --- CUSTOM AUDIO PLAYER FUNCTIONALITY ---
        function setupAudioPlayer() {
            // Play/Pause functionality
            playPauseBtn.onclick = () => {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    playPauseBtn.textContent = 'Pause';
                } else {
                    audioPlayer.pause();
                    playPauseBtn.textContent = 'Play';
                }
            };

            // Stop functionality
            stopBtn.onclick = () => {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
                playPauseBtn.textContent = 'Play';
                updateProgress();
            };

            // Volume control
            volumeSlider.oninput = (e) => {
                audioPlayer.volume = e.target.value;
            };

            // Progress bar click to seek
            progressContainer.onclick = (e) => {
                if (audioPlayer.duration) {
                    const rect = progressContainer.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const percentage = clickX / rect.width;
                    audioPlayer.currentTime = percentage * audioPlayer.duration;
                }
            };

            // Audio event listeners
            audioPlayer.addEventListener('timeupdate', updateProgress);
            audioPlayer.addEventListener('loadedmetadata', () => {
                totalTimeEl.textContent = formatTime(audioPlayer.duration);
            });
            audioPlayer.addEventListener('ended', () => {
                playPauseBtn.textContent = 'Play';
                updateProgress();
            });
        }

        function updateProgress() {
            if (audioPlayer.duration) {
                const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progressBar.style.width = progress + '%';
                currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
                
                // Update chart visualization with current playback position
                updateChartPlaybackPosition(audioPlayer.currentTime);
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateChartPlaybackPosition(currentTime) {
            if (accuracyChart && currentAudioHistory.length > 0) {
                // Find the closest data point to current time
                const targetTime = parseFloat(currentTime.toFixed(2));
                const dataPoint = currentAudioHistory.find(item => 
                    Math.abs(parseFloat(item.time) - targetTime) < 0.1
                );
                
                // Update chart with playback indicator
                if (dataPoint && accuracyChart.data.datasets.length > 1) {
                    // Remove existing playback line if it exists
                    accuracyChart.data.datasets = accuracyChart.data.datasets.filter(
                        dataset => dataset.label !== 'Current Position'
                    );
                }
                
                // Add playback position indicator
                const timeIndex = currentAudioHistory.findIndex(item => 
                    parseFloat(item.time) >= targetTime
                );
                
                if (timeIndex !== -1) {
                    const playbackData = new Array(currentAudioHistory.length).fill(null);
                    playbackData[timeIndex] = parseFloat(currentAudioHistory[timeIndex].accuracy);
                    
                    accuracyChart.data.datasets.push({
                        label: 'Current Position',
                        data: playbackData,
                        borderColor: '#e53e3e',
                        backgroundColor: 'rgba(229, 62, 62, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        pointBackgroundColor: '#e53e3e',
                        pointBorderColor: '#c53030',
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        showLine: false
                    });
                    
                    accuracyChart.update('none');
                }
            }
        }

        // Initialize audio player when page loads
        setupAudioPlayer();

        // --- UI & UTILITY FUNCTIONS ---
        function renderAccuracyChart(history) {
            if (!history || history.length === 0) {
                if (accuracyChart) {
                    accuracyChart.destroy();
                    accuracyChart = null;
                }
                return;
            }

            const ctx = accuracyChartCanvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (accuracyChart) {
                accuracyChart.destroy();
            }

            const labels = history.map(item => `${item.time}s`);
            const accuracyData = history.map(item => parseFloat(item.accuracy));

            accuracyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Note Accuracy (%)',
                        data: accuracyData,
                        borderColor: '#4299e1',
                        backgroundColor: 'rgba(66, 153, 225, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: '#4299e1',
                        pointBorderColor: '#2b6cb0',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Accuracy (%)'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    return `Time: ${context[0].label}`;
                                },
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    const item = history[dataIndex];
                                    return [
                                        `Accuracy: ${item.accuracy}%`,
                                        `Note: ${item.noteName}`,
                                        `Frequency: ${item.pitch}Hz`,
                                        `Cents: ${item.cents}`
                                    ];
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0 && audioPlayer.duration) {
                            const element = elements[0];
                            const timeValue = parseFloat(history[element.index].time);
                            audioPlayer.currentTime = timeValue;
                            updateProgress();
                        }
                    }
                }
            });
        }

        function displayHistory(history, type) {
            if (history.length > 0) {
                historyLog.innerHTML = history.map(item => 
                    `Time: ${item.time}s | Freq: ${item.pitch}Hz | Note: ${item.noteName} | Cents: ${item.cents} | Accuracy: ${item.accuracy}%`
                ).join('<br>');
                
                // Store current audio history for chart interaction
                currentAudioHistory = history;
                
                // Show custom audio player if audio is loaded
                if (audioPlayer.src) {
                    audioPlayerContainer.style.display = 'block';
                }
                
                // Render the accuracy chart
                renderAccuracyChart(history);
            } else {
                historyLog.innerHTML = `No clear notes were detected in the ${type === 'live' ? 'recording' : 'file'}.`;
                
                // Hide custom audio player if no data
                audioPlayerContainer.style.display = 'none';
                
                // Clear the chart if no data
                renderAccuracyChart([]);
            }
        }

        function createWavBlob(audioChunks) {
            let totalLength = 0;
            audioChunks.forEach(chunk => { totalLength += chunk.length; });
            const pcmData = new Int16Array(totalLength);
            let offset = 0;
            audioChunks.forEach(chunk => { pcmData.set(chunk, offset); offset += chunk.length; });
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const numChannels = 1, bitsPerSample = 16;
            const blockAlign = numChannels * bitsPerSample / 8;
            const byteRate = LIVE_SAMPLE_RATE * blockAlign;
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, LIVE_SAMPLE_RATE, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, true);
            new Int16Array(buffer, 44).set(pcmData);
            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>