<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Practice Server</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f4f7f9; padding: 1em; color: #333; line-height: 1.6; }
        .container { max-width: 600px; margin: 0 auto; background: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1, h2 { color: #1a202c; border-bottom: 1px solid #e2e8f0; padding-bottom: 0.5rem; margin-bottom: 1rem;}
        #status { font-weight: bold; }
        button { background-color: #4299e1; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px; transition: background-color 0.2s; }
        button:hover { background-color: #2b6cb0; }
        button:disabled { background-color: #a0aec0; cursor: not-allowed; }
        audio { margin-top: 20px; width: 100%; }
        .tuner { margin-top: 2rem; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; }
        .tuner-display { display: flex; justify-content: space-around; text-align: center; font-size: 1.2em; }
        .tuner-display div { flex: 1; }
        .tuner-display span { display: block; font-size: 1.8em; font-weight: bold; }
        #historyLog { margin-top: 1rem; max-height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; padding: 1rem; border-radius: 8px; font-family: monospace; font-size: 0.9em; }
        input[type="file"] { margin-top: 10px; }
        
        /* Custom Audio Player Styles */
        .audio-player-container { margin-top: 1rem; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc; }
        .audio-player-controls { display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; }
        .audio-player-controls button { margin-right: 0; padding: 8px 16px; font-size: 14px; }
        .audio-progress-container { position: relative; width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; cursor: pointer; margin: 0.5rem 0; }
        .audio-progress-bar { height: 100%; background: #4299e1; border-radius: 4px; width: 0%; transition: width 0.1s ease; }
        .audio-time-display { display: flex; justify-content: space-between; font-size: 0.9em; color: #666; margin-top: 0.25rem; }
        .audio-volume-container { display: flex; align-items: center; gap: 0.5rem; }
        .audio-volume-container input[type="range"] { width: 80px; }
        
        /* Chart Controls */
        .chart-controls { margin-top: 1rem; display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .chart-controls button { margin-right: 0; padding: 6px 12px; font-size: 14px; }
        .chart-controls label { display: flex; align-items: center; gap: 0.5rem; font-size: 14px; cursor: pointer; }
        .chart-controls input[type="checkbox"], .chart-controls input[type="range"] { margin: 0; }
        .chart-controls .zoom-control { display: flex; align-items: center; gap: 0.5rem; }
        .chart-controls .zoom-control span { font-size: 14px; min-width: 60px; }
        
        .chart-container { margin-top: 0.5rem; position: relative; height: 400px; width: 100%; overflow-x: auto; }
        .chart-container canvas { cursor: crosshair; }
        .chart-wrapper { position: relative; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Music Practice Server</h1>
        <p>Status: <span id="status">Connecting...</span></p>
        
        <h2>Live Recording</h2>
        <div>
            <button id="recordBtn">Record 5s</button>
            <button id="playBtn" disabled>Play</button>
        </div>
        
        <hr style="margin: 2rem 0;">

        <h2>Analyze WAV File</h2>
        <input type="file" id="fileInput" accept=".wav">
        <audio id="audioPlayer" controls style="display: none;"></audio>
        
        <div id="historyLog">Analysis history will appear here...</div>
        
        <!-- Custom Audio Player Interface -->
        <div class="audio-player-container" id="audioPlayerContainer" style="display: none;">
            <h3 style="margin-top: 0; margin-bottom: 1rem;">Audio Player</h3>
            <div class="audio-player-controls">
                <button id="playPauseBtn">Play</button>
                <button id="stopBtn">Stop</button>
                <div class="audio-volume-container">
                    <span>ðŸ”Š</span>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1">
                </div>
            </div>
            <div class="audio-progress-container" id="progressContainer">
                <div class="audio-progress-bar" id="progressBar"></div>
            </div>
            <div class="audio-time-display">
                <span id="currentTime">0:00</span>
                <span id="totalTime">0:00</span>
            </div>
        </div>
        
        <!-- Chart Controls -->
        <div class="chart-controls" id="chartControls" style="display: none;">
            <label>
                <input type="checkbox" id="showDataPoints" checked>
                Show Data Points
            </label>
            <div class="zoom-control">
                <span>Zoom:</span>
                <input type="range" id="zoomSlider" min="10" max="100" value="30" step="5">
                <span id="zoomValue">30px</span>
            </div>
            <button id="resetZoomBtn">Reset Scroll</button>
        </div>
        
        <div class="chart-container">
            <div class="chart-wrapper">
                <canvas id="accuracyChart"></canvas>
            </div>
        </div>

        <div class="tuner">
            <h2>Real-Time Tuner</h2>
            <div class="tuner-display">
                <div>Note<span id="note">--</span></div>
                <div>Freq (Hz)<span id="frequency">--</span></div>
                <div>Cents<span id="cents">--</span></div>
                <div>Accuracy<span id="accuracy">--</span></div>
            </div>
        </div>
    </div>

    <!-- SCRIPT IS NOW A MODULE TO SUPPORT ESM IMPORT -->
    <script type="module">
        // Import the PitchDetector class from the pitchy ES Module
        import { PitchDetector } from 'https://esm.sh/pitchy@4.1.0';

        // DOM Elements
        const statusElement = document.getElementById('status');
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const audioPlayer = document.getElementById('audioPlayer');
        const noteEl = document.getElementById('note');
        const frequencyEl = document.getElementById('frequency');
        const centsEl = document.getElementById('cents');
        const accuracyEl = document.getElementById('accuracy');
        const historyLog = document.getElementById('historyLog');
        const fileInput = document.getElementById('fileInput');
        const accuracyChartCanvas = document.getElementById('accuracyChart');
        
        // Custom Audio Player Elements
        const audioPlayerContainer = document.getElementById('audioPlayerContainer');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const volumeSlider = document.getElementById('volumeSlider');
        
        // Chart Control Elements
        const chartControls = document.getElementById('chartControls');
        const showDataPointsCheckbox = document.getElementById('showDataPoints');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');

        // Audio & Recording Constants
        const LIVE_SAMPLE_RATE = 16000;
        const RECORD_DURATION_MS = 5000;
        const ANALYSIS_BUFFER_SIZE = 2048;

        // State Variables
        let isRecording = false;
        let audioChunks = [];
        let accuracyHistory = [];
        let pitchyDetector;
        let audioContext;
        let accuracyChart;
        let currentAudioHistory = []; // Store current audio analysis history
        let showDataPoints = true; // Track data points visibility
        let zoomLevel = 30; // Track zoom level (pixels per data point)
        
        // --- NOTE & FREQUENCY DATA ---
        const A4 = 440;
        const noteNames = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
        const standardFrequencies = {};
        for (let i = 0; i < 88; i++) {
            const freq = A4 * Math.pow(2, (i - 48) / 12);
            const octave = Math.floor((i + 9) / 12); //change - remove -1
            const noteName = noteNames[i % 12];
            standardFrequencies[freq] = `${noteName}${octave}`;
        }
        const sortedFreqs = Object.keys(standardFrequencies).map(Number).sort((a, b) => a - b);


        // --- WEBSOCKET SETUP ---
        const ws = new WebSocket(`ws://${window.location.host}`);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            console.log('WebSocket connection opened');
            statusElement.textContent = 'Connected';
            statusElement.style.color = 'green';
        };

        ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
                const pcmData = new Int16Array(event.data);
                if (isRecording) {
                    audioChunks.push(pcmData);
                }
                const analysisResult = analyzePitch(pcmData, LIVE_SAMPLE_RATE);
                if (isRecording && analysisResult) {
                     const time = (audioChunks.length * pcmData.length / LIVE_SAMPLE_RATE).toFixed(2);
                     accuracyHistory.push({ time, ...analysisResult });
                }
            }
        };

        ws.onclose = () => {
            console.log('WebSocket connection closed');
            statusElement.textContent = 'Disconnected';
            statusElement.style.color = 'red';
        };

        // --- PITCH DETECTION & ANALYSIS ---
        window.addEventListener('load', () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            // Use the imported PitchDetector directly
            pitchyDetector = PitchDetector.forFloat32Array(ANALYSIS_BUFFER_SIZE);
        });

        function analyzePitch(pcmData, sampleRate) {
            if (!pitchyDetector) return null;

            let pcmFloat32Data;
            if (pcmData instanceof Int16Array) {
                pcmFloat32Data = new Float32Array(pcmData.length);
                for (let i = 0; i < pcmData.length; i++) {
                    pcmFloat32Data[i] = pcmData[i] / 32768.0;
                }
            } else {
                pcmFloat32Data = pcmData;
            }

            const [pitch, clarity] = pitchyDetector.findPitch(pcmFloat32Data, sampleRate);

            // Lowered clarity threshold for better detection of pure tones
            if (clarity > 0.9) {
                const { targetFreq, noteName } = findClosestNote(pitch);
                const cents = 1200 * Math.log2(pitch / targetFreq);
                const accuracy = Math.max(0, 100 - (Math.abs(cents) * 2));

                noteEl.textContent = noteName;
                frequencyEl.textContent = pitch.toFixed(1);
                centsEl.textContent = cents.toFixed(1);
                accuracyEl.textContent = `${accuracy.toFixed(0)}%`;

                return { pitch: pitch.toFixed(1), noteName, cents: cents.toFixed(1), accuracy: accuracy.toFixed(0) };
            }
            return null;
        }

        function findClosestNote(frequency) {
            let closestFreq = sortedFreqs[0];
            for (let i = 1; i < sortedFreqs.length; i++) {
                if (Math.abs(sortedFreqs[i] - frequency) < Math.abs(closestFreq - frequency)) {
                    closestFreq = sortedFreqs[i];
                }
            }
            return { targetFreq: closestFreq, noteName: standardFrequencies[closestFreq] };
        }


        // --- LIVE RECORDING & PLAYBACK ---
        recordBtn.onclick = () => {
            isRecording = true;
            recordBtn.disabled = true;
            playBtn.disabled = true;
            audioChunks = [];
            accuracyHistory = [];
            historyLog.innerHTML = 'Recording live audio...';
            statusElement.textContent = 'Recording...';

            setTimeout(() => {
                isRecording = false;
                recordBtn.disabled = false;
                statusElement.textContent = 'Recording finished.';
                
                displayHistory(accuracyHistory, 'live');

                if (audioChunks.length > 0) {
                    const audioBlob = createWavBlob(audioChunks);
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayer.src = audioUrl;
                    playBtn.disabled = false;
                    
                    // Show custom audio player
                    audioPlayerContainer.style.display = 'block';
                } else {
                    historyLog.innerHTML = 'No audio data received during recording.';
                }
            }, RECORD_DURATION_MS);
        };
        
        playBtn.onclick = () => {
            audioPlayer.play();
        };

        // --- FILE UPLOAD & ANALYSIS ---
        fileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                //historyLog.innerHTML = 'Analyzing file...';
                //historyLog.innerHTML = JSON.stringify(standardFrequencies, null, 2);

                
                audioContext.decodeAudioData(e.target.result, (audioBuffer) => {
                    const pcmData = audioBuffer.getChannelData(0);
                    const sampleRate = audioBuffer.sampleRate;
                    const fileAccuracyHistory = [];

                    for (let i = 0; i < pcmData.length - ANALYSIS_BUFFER_SIZE; i += ANALYSIS_BUFFER_SIZE) {
                        const chunk = pcmData.slice(i, i + ANALYSIS_BUFFER_SIZE);
                        const result = analyzePitch(chunk, sampleRate);
                        if(result) {
                            const time = (i / sampleRate).toFixed(2);
                            fileAccuracyHistory.push({ time, ...result });
                        }
                        console.log(i);
                        
                    }
                    console.log("pcmdata length: " + pcmData.length);
                    displayHistory(fileAccuracyHistory, 'file');
                    
                    const fileUrl = URL.createObjectURL(file);
                    audioPlayer.src = fileUrl;
                    playBtn.disabled = false;
                    
                    // Show custom audio player
                    audioPlayerContainer.style.display = 'block';
                });
            };
            reader.readAsArrayBuffer(file);

            
        };

        // --- CUSTOM AUDIO PLAYER FUNCTIONALITY ---
        function setupAudioPlayer() {
            // Play/Pause functionality
            playPauseBtn.onclick = () => {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    playPauseBtn.textContent = 'Pause';
                } else {
                    audioPlayer.pause();
                    playPauseBtn.textContent = 'Play';
                }
            };

            // Stop functionality
            stopBtn.onclick = () => {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
                playPauseBtn.textContent = 'Play';
                updateProgress();
            };

            // Volume control
            volumeSlider.oninput = (e) => {
                audioPlayer.volume = e.target.value;
            };

            // Progress bar click to seek
            progressContainer.onclick = (e) => {
                if (audioPlayer.duration) {
                    const rect = progressContainer.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const percentage = clickX / rect.width;
                    audioPlayer.currentTime = percentage * audioPlayer.duration;
                }
            };

            // Audio event listeners
            audioPlayer.addEventListener('timeupdate', updateProgress);
            audioPlayer.addEventListener('loadedmetadata', () => {
                totalTimeEl.textContent = formatTime(audioPlayer.duration);
            });
            audioPlayer.addEventListener('ended', () => {
                playPauseBtn.textContent = 'Play';
                updateProgress();
            });
        }

        function updateProgress() {
            if (audioPlayer.duration) {
                const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progressBar.style.width = progress + '%';
                currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
                
                // Update chart visualization with current playback position
                updateChartPlaybackPosition(audioPlayer.currentTime);
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateChartPlaybackPosition(currentTime) {
            if (accuracyChart && currentAudioHistory.length > 0) {
                // Find the closest data point to current time
                const targetTime = parseFloat(currentTime.toFixed(2));
                const dataPoint = currentAudioHistory.find(item => 
                    Math.abs(parseFloat(item.time) - targetTime) < 0.1
                );
                
                // Update chart with playback indicator
                if (dataPoint && accuracyChart.data.datasets.length > 1) {
                    // Remove existing playback line if it exists
                    accuracyChart.data.datasets = accuracyChart.data.datasets.filter(
                        dataset => dataset.label !== 'Current Position'
                    );
                }
                
                // Add playback position indicator
                const timeIndex = currentAudioHistory.findIndex(item => 
                    parseFloat(item.time) >= targetTime
                );
                
                if (timeIndex !== -1) {
                    const playbackData = new Array(currentAudioHistory.length).fill(null);
                    playbackData[timeIndex] = parseFloat(currentAudioHistory[timeIndex].accuracy);
                    
                    accuracyChart.data.datasets.push({
                        label: 'Current Position',
                        data: playbackData,
                        borderColor: '#e53e3e',
                        backgroundColor: 'rgba(229, 62, 62, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        pointBackgroundColor: '#e53e3e',
                        pointBorderColor: '#c53030',
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        showLine: false
                    });
                    
                    accuracyChart.update('none');
                }
            }
        }

        // Initialize audio player when page loads
        setupAudioPlayer();

        // Initialize chart controls
        setupChartControls();

        // --- CHART CONTROLS FUNCTIONALITY ---
        function setupChartControls() {
            // Data points visibility toggle
            showDataPointsCheckbox.onchange = (e) => {
                showDataPoints = e.target.checked;
                if (accuracyChart) {
                    updateDataPointsVisibility();
                }
            };

            // Zoom level control
            zoomSlider.oninput = (e) => {
                zoomLevel = parseInt(e.target.value);
                zoomValue.textContent = zoomLevel + 'px';
                // Re-render chart with new zoom level
                if (currentAudioHistory.length > 0) {
                    renderAccuracyChart(currentAudioHistory);
                }
            };

            // Reset scroll button
            resetZoomBtn.onclick = () => {
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer) {
                    chartContainer.scrollLeft = 0;
                }
            };
        }

        function updateDataPointsVisibility() {
            if (accuracyChart && accuracyChart.data.datasets.length > 0) {
                // Update all datasets
                accuracyChart.data.datasets.forEach(dataset => {
                    if (dataset.label === 'Note Accuracy (%)') {
                        dataset.pointRadius = showDataPoints ? 4 : 0;
                        dataset.pointHoverRadius = showDataPoints ? 6 : 0;
                    } else if (dataset.label === 'Current Position') {
                        dataset.pointRadius = showDataPoints ? 6 : 0;
                        dataset.pointHoverRadius = showDataPoints ? 8 : 0;
                    }
                });
                
                accuracyChart.update('none');
            }
        }

        // --- UI & UTILITY FUNCTIONS ---
        function renderAccuracyChart(history) {
            if (!history || history.length === 0) {
                if (accuracyChart) {
                    accuracyChart.destroy();
                    accuracyChart = null;
                }
                return;
            }

            try {
                const ctx = accuracyChartCanvas.getContext('2d');
                
                // Destroy existing chart if it exists
                if (accuracyChart) {
                    accuracyChart.destroy();
                }

                // Sample data for very long audio files to prevent Chart.js crashes
                let processedHistory = history;
                const maxDataPoints = 1000; // Maximum data points to prevent crashes
                
                if (history.length > maxDataPoints) {
                    const step = Math.ceil(history.length / maxDataPoints);
                    processedHistory = history.filter((_, index) => index % step === 0);
                    console.log(`Sampled ${history.length} data points down to ${processedHistory.length} for chart rendering`);
                }

                const labels = processedHistory.map(item => `${item.time}s`);
                const accuracyData = processedHistory.map(item => parseFloat(item.accuracy));

                // Calculate chart width using zoom level - limit maximum width to prevent issues
                const maxWidth = 10000; // Maximum chart width to prevent crashes
                const chartWidth = Math.min(maxWidth, Math.max(600, labels.length * zoomLevel));
                
                // Set the chart wrapper width to enable horizontal scrolling
                const chartWrapper = document.querySelector('.chart-wrapper');
                chartWrapper.style.width = chartWidth + 'px';

                accuracyChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Note Accuracy (%)',
                            data: accuracyData,
                            borderColor: '#4299e1',
                            backgroundColor: 'rgba(66, 153, 225, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#4299e1',
                            pointBorderColor: '#2b6cb0',
                            pointRadius: showDataPoints ? 4 : 0,
                            pointHoverRadius: showDataPoints ? 6 : 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        width: chartWidth,
                        height: 400,
                        animation: {
                            duration: 0 // Disable animations for better performance with large datasets
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Accuracy (%)'
                                },
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time (seconds)'
                                },
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                },
                                ticks: {
                                    maxTicksLimit: Math.min(20, labels.length)
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    title: function(context) {
                                        return `Time: ${context[0].label}`;
                                    },
                                    label: function(context) {
                                        const dataIndex = context.dataIndex;
                                        const item = processedHistory[dataIndex];
                                        return [
                                            `Accuracy: ${item.accuracy}%`,
                                            `Note: ${item.noteName}`,
                                            `Frequency: ${item.pitch}Hz`,
                                            `Cents: ${item.cents}`
                                        ];
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0 && audioPlayer.duration) {
                                const element = elements[0];
                                const timeValue = parseFloat(processedHistory[element.index].time);
                                audioPlayer.currentTime = timeValue;
                                updateProgress();
                            }
                        }
                    }
                });

                // Update the currentAudioHistory to use processed data for playback position tracking
                currentAudioHistory = processedHistory;

            } catch (error) {
                console.error('Error rendering chart:', error);
                // Fallback: show a simple message instead of the chart
                accuracyChartCanvas.style.display = 'none';
                const chartContainer = document.querySelector('.chart-container');
                if (!chartContainer.querySelector('.chart-error')) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'chart-error';
                    errorDiv.innerHTML = `
                        <div style="padding: 2rem; text-align: center; color: #666;">
                            <p>Chart rendering failed for this audio file.</p>
                            <p>The audio file may be too long or complex for visualization.</p>
                            <p>You can still use the audio player and analysis log above.</p>
                        </div>
                    `;
                    chartContainer.appendChild(errorDiv);
                }
            }
        }

        function displayHistory(history, type) {
            if (history.length > 0) {
                let logContent = history.map(item => 
                    `Time: ${item.time}s | Freq: ${item.pitch}Hz | Note: ${item.noteName} | Cents: ${item.cents} | Accuracy: ${item.accuracy}%`
                ).join('<br>');
                
                // Add sampling notice if data was sampled
                if (history.length > 1000) {
                    logContent = `<div style="background: #fff3cd; padding: 0.5rem; margin-bottom: 0.5rem; border-radius: 4px; border-left: 4px solid #ffc107;">
                        <strong>Note:</strong> This audio file has ${history.length} data points. The chart shows a sampled version (max 1000 points) for better performance. 
                        All ${history.length} data points are shown in this log.
                    </div>` + logContent;
                }
                
                historyLog.innerHTML = logContent;
                
                // Store current audio history for chart interaction
                currentAudioHistory = history;
                
                // Show custom audio player if audio is loaded
                if (audioPlayer.src) {
                    audioPlayerContainer.style.display = 'block';
                }
                
                // Show chart controls
                chartControls.style.display = 'flex';
                
                // Render the accuracy chart
                renderAccuracyChart(history);
            } else {
                historyLog.innerHTML = `No clear notes were detected in the ${type === 'live' ? 'recording' : 'file'}.`;
                
                // Hide custom audio player if no data
                audioPlayerContainer.style.display = 'none';
                
                // Hide chart controls if no data
                chartControls.style.display = 'none';
                
                // Clear the chart if no data
                renderAccuracyChart([]);
            }
        }

        function createWavBlob(audioChunks) {
            let totalLength = 0;
            audioChunks.forEach(chunk => { totalLength += chunk.length; });
            const pcmData = new Int16Array(totalLength);
            let offset = 0;
            audioChunks.forEach(chunk => { pcmData.set(chunk, offset); offset += chunk.length; });
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const numChannels = 1, bitsPerSample = 16;
            const blockAlign = numChannels * bitsPerSample / 8;
            const byteRate = LIVE_SAMPLE_RATE * blockAlign;
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, LIVE_SAMPLE_RATE, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, true);
            new Int16Array(buffer, 44).set(pcmData);
            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>